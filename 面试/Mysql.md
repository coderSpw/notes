# Mysql

## 1. ACID基本特性？ ACID靠什么保证？出现问题？ 隔离级别？

1.  基本特性 & 靠什么保证

   - 原子性（Atomicity）：保证一个事务操作完整性，要么全部成功，要么全部失败。

     主要通过undo log 日志保证， 主要记录回滚日志信息；

   - 一致性（Consistency）：数据要处于一致状态，事务运行不会改变数据库的一致性约束；

     主要是靠其余三大特性保证的，同时靠程序代码保证；

   - 隔离性（Isolation）：一个事务的操作不会受其他事务影响。

     主要通过MVCC（多版本并发控制）和 LBCC（锁并发控制）

   - 持久性（durability）： 事务操作完成之后数据永久保存。

     主要通过内存 + redo log日志保证， 数据修改会同时修改内存和redo log中的记录，宕机后可以

     操作redo log进行恢复；

2. 出现问题 & 隔离级别

   	1. 出现问题
       - 脏读： 读取到未提交事务的数据
       - 不可重复读： 读取到已提交事务的update更新数据；
       - 幻读：读取到已提交事务的insert/delete新增或删除数据；
   	2. 隔离级别
       - 读未提交(READ_UNCOMMITED)：会出现脏读；
       - 读已提交(READ_COMMITED)：解决脏读但会出现不可重复读；
       - 可重复读(REPEATABLE_READ)：解决脏读和不可重复读但会出现幻读；
       - 串行化(serializable)：串行化，将所有事务按顺序执行问题都能解决但是会影响性能；

## 2. B树和B+树的区别？为什么Mysql的InnoDB默认使用B+树

- B树：根据节点排序且每个节点会存放多条记录；
- B+树： 只有叶子节点存放数据，每个节点同样会存放多条记录，节点之间使用双向指针连接，每个节点相当于一个页（16k），同时存放索引指针和记录信息；

​	先从hash索引来说，hash索引就是存放一个数据然后对记录的主键使用hash算法来获取存放位置，hash值相同会出现hash冲突，相同hash的数据会采用链表存储；对于精确查询hash值很快，但是如果是范围或者模糊查询的话会需要全表扫描，效率不高；

然后是为什么不使用二叉树，因为二叉树存储会进行排序，左子节点的数小于当前节点数，右子节点的数大于当前数，如果存放的递增数据的话，二叉树会变成的单向链表；

针对于二叉树的劣质，可以转换为平衡二叉树（AVL树），特点是左右子树的高度差不能超过1，通过左旋右旋 自旋的方式来平衡节点个数，但是数据多的话会导致树的深度变高，查询效率也会变低；

针对于上面这些情况出现了B树，B树主要特点是每个节点会存放多条记录，来减少树的深度，此时如果查询的数据不在一个页中，会重新遍历来查询；

进一步优化为B+树，特点是每个节点有多个子节点，每个节点中会存放多条记录，叶子节点存放记录数据，同时叶子节点之间采用双向链表连接；

这样范围查询的话可以根据链表来找到相邻页的数据；

## 3. InnoDB是如何实现事务的

使用update操作举例来说：

1. 收到update语句，会根据更新条件找到所在的页，将该页缓存到buffer pool中；
2. 执行update语句，修改buffer pool中的数据；
3. 根据update语句生成一个RedoLog对象，存入到LogBuffer中；
4. 生成undo log 日志用于回滚操作；
5. 如果提交的话，会将redoLog对象持久化到redo log日志中，同时生成commit记录；
6. 如果回滚的话，使用undo log日志进行回滚；

## 4. mysql聚簇和非聚簇索引的区别

1. 聚簇索引：分为主键索引和唯一索引，每个索引相当于是一个B+树，叶子节点会存放记录数据；

2. 非聚簇索引：也是辅助索引，叶子节点存放聚簇索引的地址以及当前辅助索引列中的数据，如果查询的列不在索引中，会进行回表操作，就是先在非聚簇索引中找到记录，通过聚簇索引的地址找到具体数据的位置，以此来获取完整数据记录；

   InnoDB下的表聚簇索引扫描会先看是否有主键，没有主键的话查找唯一索引，不存在使用隐藏列row_id；

## 5. mysql慢查询如何优化

1. 首先要定位查询慢的sql，如果是程序的话可以使用durid连接池的图形化界面，代码中配置；也可以通过mysql开启慢查询日志，slow_query_log设置为true, slow_query_log_file慢日志文件存放位置，long_query_time设置查询时间阈值，单位秒;

2. 获取到慢sql，通过explain分析查询语句，首先看是否使用到索引以及使用索引的类型，

   const > eq_ref > ref > index > all 

   如果表中没有创建索引，就创建索引，有索引但是失效，看索引是否出现导致失效出现的几种写法；

3. 查看extra列，如果出现using filesort, 这个是排序字段未使用索引的列；

   如果出现using tempporary，使用临时表，经常出现在group by 和 order by;

## 6. mysql锁的类型

1. 根据属性划分为： 排他锁和共享锁
   - 排他锁：就是写锁，使用排他锁后，多个事务之间既不能读也不能写；
   - 共享锁：就是读锁，使用共享锁后，多个事务之间可以读操作，但不能写；
2. 根据粒度划分为：表锁、页锁、行锁、记录锁、间隙锁、临建锁；
   - 表锁：整个表进行上锁；
   - 页锁：每个页进行上锁，属于表锁和行锁的中间方法；
   - 行锁：一条记录或一个范围内的记录上锁；
   - 记录锁：精确的一条记录上锁；
   - 间隙锁：一个区间范围上锁，使用左开右闭原则；
   - 临建锁：记录锁+间隙锁的组合，对整个区间范围上锁，会把查询出来的范围内的数据都上锁；

## 7. mysql的分为哪几种存储引擎

通过show engins；语句查看mysql中的所有存储引擎，主要使用的是MySIAM和InnoDB；

![image-20220517182918333](https://raw.staticdn.net/coderSpw/notes/master/note_img/image-20220517182918333.png)

## 8. MySIAM和InnoDB的区别

1. InnoDB支持事务、行锁、外键；
2. MySIAM的表会记录数据总数；
3. 存储文件不同，MyISAM分为两个文件存储.myi(索引)和.myd(数据)，InnoDB数据和索引存放在mdb中；
4. B+树存储结构不同，MyISAM索引的B+树叶子节点不会存放真是记录数据，只存放数据的地址；
5. InnoDB支持XA事务和Savepoints，批量插入sql回滚到指定位置；

##  9. 什么是MVCC

MVCC：mutil-version concurrent control 多版本并发控制

只能在 READ COMMITED和  REPEATABLE READ级别下操作

每张表都会有两个隐藏列，一个是trx_id：事务id，存放当前事务的id； 另一个是roll_pointer：回滚指针，记录undo log 上一次修改的数据的地址；

每当开启事务会创建一个readView数组，主要存放一些正在事务中单位提交的事务id, 当查询的事务id小于readView数组中的值时可以查询，当trx_id大于数组中的值或在数组中的时候，证明当前事务未结束，查询不到，

如果在数组中，会使用roll_pointer字段找到上一个事务数据，再进行比较，循环遍历获取直到小于readView中的值则查询成功；

## 10. mysql主从同步原理

1. 主库生成数据写入到bin log 日志中；
2. 主库开启dump线程，当bin log出现变动，将变动的数据发送给从库；
3. 从库开启I/O线程接收bin log内容，将数据写入到relay log中；
4. 从库开启sql线程从relay log中读取数据写入库中；

**主从节点之间使用bin log + position定位同步位置**

![img](https://raw.staticdn.net/coderSpw/notes/master/note_img/06ea7f60781b48c29cf2cb8af5189d61.png)