# Redis

## 1. Redis单线程为什么这么快

1. 基于内存，数据都存储在内存中，相比存储磁盘速度快；
2. 采用单线程方式，避免多线程造成的线程上下文切换；
3. 采用非阻塞IO多路复用机制，将客户端请求的socket存放到队列中，然后遍历分配给对应的事件处理器处理；

**流程：**

1. redis服务器启动，创建AE_READABLE事件绑定连接应答处理器；
2. 客户端发起连接会生成AE_READABLE事件，连接应答处理器与客户端连接，创建对应的socket，同时将socket的AE_READABLE事件有事件分派器分派给命令请求处理器处理，此时客户端可以向服务器发送命令；
3. 客户端发送命令，也会生成AE_READABLE事件，有事件分派器将socket分派给命令请求处理器来处理客户端发送的命令；
4. 当服务器准备好给客户端的响应数据时，会生成AE_WRITABLE事件，将这个事件与命令回复处理器绑定，当客户端准备好读取服务器响应的数据时，也会生成AE_WRITABLE事件，与对应的命令回复处理器处理，将准备好的数据写入到socket中响应给客户端。

## 2. Redis的持久化机制

redis持久化分为：RDB和AOF两种

1. RDB（redis database）：一种紧凑型的二级制文件，持久化时只会生成一个文件dump.rdb；

   持久化时主进程会fork一个子进程，此时会进入阻塞状态，由子进程来持久化数据生成rdb文件，同时采用了操作系统的写时复制方式，会将共享内存拷贝一份来写入持久化过程中新增加的命令；

   方式：

   	1. 手动触发：
   	- save：会是线程阻塞；
   	- bgsave：fork子线程来持久化；
   	2. 自动触发：
   		1. 配置文件配置 bgsave m n ，会每隔m秒新增n个key，触发持久化，宕机后会确实m秒事件的数据；
   		2. 主从全量复制会触发主节点fork子线程生成dump.rdb文件；
   		3. 执行flushall或flushdb会清空rdb文件，同时生成一个空的rdb文件；

2. AOF(append only file)：存储修改命令的文件，会在文件中进行追加命令，不追加查询命令；

   首先会将命令写入到缓冲区中，通过同步磁盘策略进行持久化，文件过大，会进行rewrite重写，主要是删除一些无效指令以及合并指令；

   同步磁盘策略分为：

   - always：执行命令就会触发
   - everysec: 每秒持久化一次
   - no: 依靠操作系统进行持久化

## 3. Redis过期键删除策略

1. 惰性删除：查询设置expire过期时间的key时，判断当前key是否过期，过期则删除；这种方式如果存储一些key但是永远不会访问，会浪费内存空间，但节省了CPU资源；
2. 定期删除：在一定时间内(默认每隔100ms)，会扫描一定数量的设置expires的key, 清除其中过期的key；

redis中同时使用这两种过期策略

## 4. 内存淘汰策略

通过配置文件maxmemory 1g 设置redis最大内存，当内存中的数据到达设置的内存上限时，会采用淘汰策略来淘汰数据；

1. noevction: 不淘汰数据，此时新增数据会报错，但是可以查询；
2. 所有键
   1. allkeys-lru：所有key中最久未使用的key删除
   2. allkeys-random: 所有key中随机删除key
   3. allkeys-lfu: 所有key中删除使用频率最少的key
3. 设置过期时间的键
   1. volatile-lru: 设置过期时间且最久未使用的key
   2. volatile-random: 设置过期时间随机删除key
   3. volatile-lfu: 设置过期时间删除使用频率最少的key
   4. vuolatile-ttl: 删除马上快过期的key

## 5. redis分布式锁底层是如何实现的

1. 通过setNX设置分布式锁，如果当前key不存在，设置锁成功，存在失败；
2. 通过lua脚本来将设置锁和设置过期时间组合到一起，实现原子性操作；
3. 通过添加watch定时任务，来针对锁进行续期，可以使用redisson，内部实现看门狗，每个10s自动续期；
4. 通过redisson+redlock来实现，集群下单节点宕机导致锁失效问题，主要会给请求每个节点进行上锁，只要通过(N+1)/2答应，则上锁成功；

## 6. 缓存雪崩、缓存穿透、缓存击穿

1. 缓存雪崩：一个时间点，大量的key过期，导致大部分请求穿过缓存打在数据库中；

   解决方案： 

   	1. 给过期时间添加随机数，平均分配过期时间；
   	1. 缓存预热；
   	1. 使用分布式锁，每个key只有一个可以上锁成功；

2. 缓存穿透：大量请求访问数据库中不存在的key，导致穿过缓存，造成数据库压力；

   解决方案：

   	1. 使用布隆过滤器，一个bitmap结构，这种设计不存在的key一定会被拦截，但存在的key可能会被拦截；
   	1. 接口校验，恶意参数拦截；
   	1. 存储恶意访问key，值为null，同时设置过期时间;

3. 缓存击穿：一个时间点，热点key失效，大量请求访问该热点key,倒是穿过缓存打在数据库上，造成数据库压力；

   解决方案：

   	1. 使用互斥锁+自旋；
   	1. 设置热点数据永不过期；

## 7. 如何保证数据库与缓存双写一致性

1. 使用最多的方案，

   查询操作，先查缓存，缓存不存在查询数据库，然后将查询结果添加到缓存中；

   修改操作，先更新数据库，再删除缓存；

   这种方案，如果并发量大的情况下，可能造成读取老数据问题，不过几率不大；

2. 修改操作，先更新数据库，再更新缓存；

   这种方案，如果一个线程先更新数据库但还没来的及更新缓存，另一个线程读操作会读取老数据；

3. 先删除缓存，再更新数据库；

   这种方案，如果一个线程删除缓存还没来得及更新数据库，另一个线程来读取数据，缓存不存在，会从数据库获取然后添加到缓存中，这样也会读取老数据；

4. 延时双删：

   先删缓存，再更新数据库，sleep几秒后再删缓存；

   如果存在主从复制，计算睡眠时间要算上主从同步延迟时间；

5. 操作串行化

   将命令放入队列中（可以是消息队列）按顺序执行命令；

## 8. redis主从复制原理

1. 从节点执行slaveof或replactionof命令首先判断是不是第一次复制，是的话向主节点发送psync命令，进行全量复制，不是的话会向主节点发送psync runid offset，如果runid相同进行增量复制，不同进行全量复制；
2. 主节点收到从节点命令，fork一个子线程进行持久化操作生成dump.rdb文件；
3. 文件生成完成向从节点发送fullresync runid offset，执行全量复制，从节点会保存runid和offset；

## 9. redis高可用方案

1. 主从模式

   一个主节点对应多个从节点，从节点同步主节点数据，首次连接增量同步，宕机后判断runid，相同进行增量同步；

2. 哨兵模式

   主要监控主从节点的状态，主节点出现问题进行故障转移，通过可以布署多个节点集群监控，多个哨兵节点互相监控状态，同时也会监控主从节点状态；当主节点出现问题一个哨兵检测到，会将该节点置为主观下线，当多个节点都认为该节点出问题，会变为客观下线，通知从节点进行选举操作；首先会看从节点中的offset偏移量，偏移量最大的会提升为主节点，如果偏移量相同，再通过判断runid，选择runid最小的变为主节点；

3. redis cluster

   服务端分片

   采用slot槽划分，总共分为16384个槽点，根据集群节点个数平均划分每个槽段分配给每个节点;

   采用CRC16(key)%16384计算存放位置；节点之间通讯采用采用gossip协议，类似于病毒协议；

4. redis sharding

​		客户端分片

​		布署多个主从集群，每个集群之间互相独立，采用客户端对key进行操作来判断打到哪个节点上；

## 10. redis的类型结构

redis底层相当于是一个hashmap, 一个head数组，出现hash冲突挂链表，每个节点dictEntry，dictEntry里面存放key/value，存放key，下一个元素的指针*next, redisObject对象的指针;

1. String 

   底层结构：

   - int

     不超过long长度的整数

   - embstr

     长度不超过44个字符的字符串，如果对字符串进行操作会转变成raw类型；

   - raw

     文本，超过44个字符；

   使用场景：

   ​	缓存，计数器

2. list

   底层结构：

   - ziplist

     紧凑型的压缩列表，限制单个数据长度不能超过64个字节，节点个数不能超过512个；

   - quicklist

     快表，底层又linklist+ziplist组成，每一段都是一个ziplist，ziplist之间使用双向指针连接；

   使用场景：

   ​     消息队列，数据分页

3. hash

   底层结构：

   - ziplist

     紧凑型的压缩列表，默认限制单个数据长度不能超过64个字节，节点个数不能超过512个；

   - hashtable

     内部包含两个table，由于扩容使用，扩容时会将旧table的元素逐渐挪到新的table中，然后删除旧table，拷贝新table；

   使用场景：

   ​	存放用户信息

4. set

   底层结构：

   - hashtable

     内部包含两个table，由于扩容使用，扩容时会将旧table的元素逐渐挪到新的table中，然后删除旧table，拷贝新table；

   - inset

     有序集合，二分查找方式查询元素；限制条件：元素都是整数，个数不小于512个

   使用场景：

   ​	共同好友

5. zset

   底层结构：

   - ziplist

     紧凑型的压缩列表，默认限制单个数据长度不能超过64个字节，节点个数不能超过512个；

   - skiplist

     跳表，分层，顶层元素范围相同，但是元素个数减少；

   使用场景：

   ​	排行榜

6. geo

   地理位置

   使用场景：

   ​	计算两人之间的直线距离，推荐所在位置指定范围内的人；

7. hyperloglog

   基数，不重复的元素 ，空间容量固定12kb

   使用场景：统计每天用户量

8. bitmaps

   只存放0和1，最大长度512m

   使用场景：上班打卡